# EX 1 - Smash the Stack 1

In this program we'll exploit our first binary overflowing a buffer with a greater length than allowed.

## Requirements

- GCC installed
- A 32bits debian VM (I use a osboxes vdi of debian server: https://www.osboxes.org/debian/) with GDB installed

## Needed mitigations knowledge 

How BOF vulnerabilities have a long history, currently there are many mitigations to protect binaries from this attacks, some may be:

- *ASLR*:	Address Space Layout Randomization or ASLR is a technology that randomizes the memory addresses making hard to attackers to calculate stack addresses and leak values or write [shellcodes](https://en.wikipedia.org/wiki/Shellcode). More info: https://en.wikipedia.org/wiki/Address_space_layout_randomization 
To manage ASLR you can execute in the linux terminal:

						To disable:
							sudo sysctl -w kernel.randomize_va_space=0

						Or:
							echo 0 > /proc/sys/kernel/randomize_va_space
														

						To enable:
							sudo sysctl -w kernel.randomize_va_space=2

						Or:
							echo 2 > /proc/sys/kernel/randomize_va_space

- *PIE*: Pie function changes randomly the memory address before each execution, such as ASLR but internally in the binary.

					To disable we need the flag `-no-pie`:
						gcc -no-pie victim.c -o victim



## Step 1 - Compilation & exploit

Once we have disabled the ASLR, we'll compile the binary with the flag `-no-pie`:

						gcc -no-pie victim.c -o victim

and execute it:

![Smash the stack](./docs/step1-a.png "Compiling")

The program continues to correctly, lets see the `victim.c` file. If we observe the source code, we'll realize that the program verifies if `target` variable was changed, we need change this variable to win the exercise, but how do we change the target variable on the fly? All we can do is fill the `buffer` with the function `gets`. 

If we execute `man gets` and go to the BUGS section, it says that we should never use that function, because this function reads our [stdin](https://en.wikipedia.org/wiki/Standard_streams)(the 'AAAAAAA') and save it in a buffer, but never count the lenght of this stdin, that is, if you have a 32 bytes buffer (char buffer[32]) and the stdin length is greater than this, gets won't care and will save all the stdin filling the buffer and continuing filling the stack memory, overwriting other variables and other things there. Obviously nowadays practically nobody use that function.

So, if what we read is true, then we can puts more than 32 'A' in the stdin and we'll overwrite `target` value and win the exercise. Lets use python to be more acurate

![Smash the stack](./docs/step1-b.png "Smashing")

Using the pipe `|`  in linux is equal to:

![Smash the stack](./docs/step1-c.png "Comparing")

Well, it works. The extra byte (number 33) will pass to `target` value, that now be 0x41 ('A' in int) and explodes the program.

In the next posts, we explain deeply what happened analyzing with gdb.

Congratulations!









