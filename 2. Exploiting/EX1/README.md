# EX 1 - Smash the Stack 1

In this program we'll exploit our first binary overflowing a buffer with a greater length than allowed.

## Requirements

- GCC installed
- A 32bits debian VM (I use a osboxes vdi of debian server: https://www.osboxes.org/debian/) 

## Step 1 - Compilation & exploit

						gcc victim.c -o victim

and execute it:

![Smash the stack](./docs/step1-a.png "Compiling")

The program continues to correctly, lets see the `victim.c` file. If we observe the source code, we'll realize that the program verifies if `target` variable was changed, we need change this variable to win the exercise, but how do we change the target variable on the fly? All we can do is fill the `buffer` with the function `gets`. 

If we execute `man gets` and go to the BUGS section, it says that we should never use that function, because this function reads our [stdin](https://en.wikipedia.org/wiki/Standard_streams)(the 'AAAAAAA') and save it in a buffer, but never count the lenght of this stdin, that is, if you have a 32 bytes buffer (char buffer[32]) and the stdin length is greater than this, gets won't care and will save all the stdin filling the buffer and continuing filling the stack memory, overwriting other variables and other things there. Obviously nowadays practically nobody use that function.

So, if what we read is true, then we can puts more than 32 'A' in the stdin and we'll overwrite `target` value and win the exercise. Lets use python to be more acurate

![Smash the stack](./docs/step1-b.png "Smashing")

Using the pipe `|`  in linux is equal to:

![Smash the stack](./docs/step1-c.png "Comparing")

Well, it works. The extra byte (number 33) will pass to `target` value, that now be 0x41 ('A' in int) and explodes the program.

In the next posts, we explain deeply what happened analyzing with gdb.

Congratulations!









