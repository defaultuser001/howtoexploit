# EX 1 - Smash the Stack 1

In this program we'll exploit our first binary overflowing a buffer with a greater length than allowed.

## Requirements

- GCC installed
- A 32bits debian VM (I use a osboxes vdi of debian server: https://www.osboxes.org/debian/) with GDB installed

## Needed mitigations knowledge 

How BOF vulnerabilities have a long history, currently there are many mitigations to protect binaries from this attacks, some may be:

- *ASLR*:	Address Space Layout Randomization or ASLR is a technology that randomizes the memory addresses making hard to attackers to calculate stack addresses and leak values or write [shellcodes](https://en.wikipedia.org/wiki/Shellcode). More info: https://en.wikipedia.org/wiki/Address_space_layout_randomization 
To manage ASLR you can execute in the linux terminal:

        To disable:
          sudo sysctl -w kernel.randomize_va_space=0

        Or:
          echo 0 > /proc/sys/kernel/randomize_va_space
                        

        To enable:
          sudo sysctl -w kernel.randomize_va_space=2

        Or:
          echo 2 > /proc/sys/kernel/randomize_va_space

- *PIE*: Pie function changes randomly the memory address before each execution, such as ASLR but internally in the binary.

        To disable we need the flag `-no-pie`:
          gcc -no-pie victim.c -o victim

- *CANARY STACK PROTECTOR*: Briefly, it's a variable with a number that indicates if the stack was modified, if you override everything, then the `canary` (the variable) also will modified and will alert than the stack is being modificated and close the program, analyzing the program is possible to avoid this protection, but for now we'll disable this feature with the flag `fno-stack-protector`:
          gcc -fno-stack-protector victim.c -o victim


## Step 1 - Compilation and first test

Once we have disabled the ASLR, we'll compile the binary with the flag `-no-pie` and `-fno-stack-protector`:

          gcc -no-pie -fno-stack-protector victim.c -o victim

and execute it:

![Compiling]('./docs/step-1-a' 'compiling')

How we can see, the program is similar to the previous exercise, let see the source code (victim.c). There are 2 int variables and one exploitable buffer, and obviously, the polemic `gets` function. One of this two variables, called `dont_touch`, literally cannot be touchedbut we need change the variable `target`. So, how do we do it? 

We can do trial and error considering the next stack diagram:

![Try and error]('./docs/step-1-b' 'Tring')

![Try and error]('./docs/step-1-c' 'Tring')

- `print 'A' * 72`: The 64 bytes buffer, but why 72 'A' if we have a 64 bytes buffer? Thats weird
- `\0\0\0\0`: The variable `dont_touch` requires 0, but the int length is 4 bytes and requires 4 characters at least to make an overflow. The `\0` instead `0` is because `\0` is a int 0 value, it's `escaped` 
- `A`: Is for the target value we need to change.

Well, we did it, but this is not enough, let's analyze with GDB

## Step 2 - GDB in action

Open GDB and disassemble main function

![Main function]('./docs/step-2-a' 'Disassemble')

Well, this is so much code, for now we'll go to the importants things.

First, in <main +19>, we have a `sub esp,0x50`. It means the compiler decided to save 0x50 or 80 bytes of space for the local funcion variables in the stack. That's why upstairs we had to use `72` padding bytes instead `64`, the compiler save additional space that we have to fill. gcc things, don't worry about that. That makes sense, because `72 buffer bytes + 4 int bytes + 4 int bytes is 80 bytes`, that's cool. 

Let's try to identify where our 72 bytes buffer is located. 

![Main function]('./docs/step-2-b' 'Identifying')

How we'll say in previous episodes, to execute a function in asm as in c, the closest argument to the function is the first function argument, therefore, for `gets(buffer)`, `[ebp-0x50]` it's our buffer address begin in the stack, this address will be pushed and poped by gets asm code.

### EBP? What is that?

In asm we only have global registers, such as `eax, ebx, ecx, esp, ebp`,etc, and the code runs sequentially instruction by instruction, and we also know in c exists the scopes, variables in function cannot be accessed by other function and viceversa, so how it works in asm? The answer is the `stack frames`.

When the program enters into a function, it  will generate a stack frame for this function execution, saving the local variables, working with that and destroying all the stack frame once the program reach the return and go back to the entry point.

In deeply, when the program will execute a function, first push in the stack the needed function params (as we see in the `gets` function) and execute the `call <function>`. The `call <function>` push the return address (that is needed to return the normal program execution when the function finish) a jump to the function code. Into the function execution code, first will push the old `ebp` register value and set a new value with the current `esp` (the stack pointer) at this time. When the function returns, it pop the old `ebp` value and continues the program from the return address it also poped. Yes, in the next attacks, we'll change the return address to return wherever we want in the program.  

The `ebp` register contains a static address both for the function arguments and for local function variables. How the ebp value has the direction of the function stack frame begin: 

-`[ebp + 0x4]` will be the function return address 
-`[ebp + 0x8]` will be the first function argument
-`[ebp - 0x4]` will be the first local variable
-`[ebp - 0x8]` will be the second local argument

from 4 to 4 because is in 32bits, in 64bits it goes from 8 to 8.

![Main function]('./docs/step-2-c' 'https://www.rootnetsec.com/buffer-overflow/')

For more info you can check [this](https://stackoverflow.com/questions/10057443/explain-the-concept-of-a-stack-frame-in-a-nutshell)

In our exercise case:

-`[ebp-0x10]`: `dont_touch` variable
-`[ebp-0xc]`: `target` variable
-`[ebp-0x50]`: `buffer` variable

So, to resolve this exercise ignoring the previous resolution and considering the 80 bytes the program sub to the stack and knowing the buffer starts in `[ebp-0x50]`, we'll create a script in python that generates an alphabet separate by 4 bytes (AAAABBBBCCCC...) to align it correctly to the stack. Then we'll put a breakpoint in the dont_touch and target to see what letter they have and calculate the exploit correctly.

![Main function]('./docs/step-2-d' 'First exploit')

Putting a breakpoint on `cmp DWORD PTR [ebp-0x10],0x0` and running the program with the exploit in stdin `r < /tmp/exp`, where `/tmp/exp` is the exploit output text file

![Main function]('./docs/step-2-e' 'Exploiting')

Ok, we see that `dont_touch` is `QQQQ` and `target` is `RRRR`. So, let's modify out exploit.
 
![Main function]('./docs/step-2-f' 'Exploited')

And there is it, exploited!

Congratulations!

In the next episode we'll create our shellcode and executes our code in the binary.








